"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * All the endpoints related to chatroom
 * @see https://www.igniterealtime.org/projects/openfire/plugins/1.3.8/restAPI/readme.html#chat-room-related-rest-endpoints
 */
var Chatroom = /** @class */ (function () {
    function Chatroom(rest) {
        this.rest = rest;
        this.endPoint = 'chatrooms';
    }
    /**
     * Create a chat room
     * @description Endpoint to create a new chat room.
     */
    Chatroom.prototype.createChatroom = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, statusCode, statusMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.rest.post(this.endPoint, {
                            json: data,
                        })];
                    case 1:
                        _a = (_b.sent()), statusCode = _a.statusCode, statusMessage = _a.statusMessage;
                        return [2 /*return*/, {
                                statusCode: statusCode,
                                statusMessage: statusMessage,
                            }];
                }
            });
        });
    };
    Chatroom.prototype.updateChatroom = function (data, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + data.roomName;
                        return [4 /*yield*/, this.rest.put(url, {
                                json: data,
                                searchParams: {
                                    servicename: servicename,
                                },
                            })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.statusCode];
                }
            });
        });
    };
    /**
     * Retrieve a chat room
     * @description Endpoint to get information over specific chat room
     */
    Chatroom.prototype.getChatroom = function (roomname, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, room;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname;
                        return [4 /*yield*/, this.rest.get(url, {
                                searchParams: {
                                    servicename: servicename,
                                },
                            })];
                    case 1:
                        room = (_a.sent());
                        return [2 /*return*/, room];
                }
            });
        });
    };
    /**
     * Retrieve chat room participants
     * @description Endpoint to get all participants with a role of specified room.
     */
    Chatroom.prototype.getChatroomParticipants = function (roomname, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, participants;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/participants";
                        return [4 /*yield*/, this.rest.get(url, { searchParams: { servicename: servicename } })];
                    case 1:
                        participants = (_a.sent());
                        return [2 /*return*/, participants];
                }
            });
        });
    };
    /**
     * Retrieve chat room occupants
     * Endpoint to get all occupants (all roles / affiliations) of a specified room.
     */
    Chatroom.prototype.getChatroomOccupants = function (roomname, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, occupants;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/occupants";
                        return [4 /*yield*/, this.rest.get(url, { searchParams: { servicename: servicename } })];
                    case 1:
                        occupants = (_a.sent());
                        return [2 /*return*/, occupants];
                }
            });
        });
    };
    /**
     * Retrieve chat room message history
     * @description Endpoint to get the chat message history of a specified room.
     */
    Chatroom.prototype.getChatroomHistory = function (roomname, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, chatHistory;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/chathistory";
                        return [4 /*yield*/, this.rest.get(url, { searchParams: { servicename: servicename } })];
                    case 1:
                        chatHistory = (_a.sent());
                        return [2 /*return*/, chatHistory];
                }
            });
        });
    };
    /**
     * Retrieve all chat rooms
     * @description Endpoint to get all chat rooms
     */
    Chatroom.prototype.getAllChatrooms = function (search, type, servicename) {
        if (search === void 0) { search = ''; }
        if (type === void 0) { type = 'public'; }
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, rooms;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "" + this.endPoint;
                        return [4 /*yield*/, this.rest.get(url, {
                                searchParams: {
                                    servicename: servicename,
                                    search: search,
                                    type: type,
                                },
                            })];
                    case 1:
                        rooms = (_a.sent());
                        return [2 /*return*/, rooms];
                }
            });
        });
    };
    /**
     * Delete a chat room
     * @description Endpoint to delete a chat room.
     */
    Chatroom.prototype.deleteChatroom = function (roomname, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, status;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname;
                        return [4 /*yield*/, this.rest.delete(url, { searchParams: { servicename: servicename } })];
                    case 1:
                        status = _a.sent();
                        return [2 /*return*/, status.statusCode];
                }
            });
        });
    };
    /**
     * Add user with role to chat room
     * @description Endpoint to add a new user with role to a room.
     */
    Chatroom.prototype.addUserToChatroom = function (roomname, username, roles, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, _a, statusCode, statusMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/" + roles + "/" + username;
                        return [4 /*yield*/, this.rest.post(url, {
                                searchParams: { servicename: servicename },
                            })];
                    case 1:
                        _a = (_b.sent()), statusCode = _a.statusCode, statusMessage = _a.statusMessage;
                        return [2 /*return*/, {
                                statusCode: statusCode,
                                statusMessage: statusMessage,
                            }];
                }
            });
        });
    };
    /**
     * Add group with role to chat room
     * @description Endpoint to add a new group with role to a room.
     */
    Chatroom.prototype.addGroupToChatroom = function (roomname, groupname, roles, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, _a, statusCode, statusMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/" + roles + "/" + groupname;
                        return [4 /*yield*/, this.rest.post(url, {
                                searchParams: { servicename: servicename },
                            })];
                    case 1:
                        _a = (_b.sent()), statusCode = _a.statusCode, statusMessage = _a.statusMessage;
                        return [2 /*return*/, {
                                statusCode: statusCode,
                                statusMessage: statusMessage,
                            }];
                }
            });
        });
    };
    /**
     * Invite user to a chat Room
     * @description Endpoint to invite a user to a room.
     */
    Chatroom.prototype.inviteUserToChatroom = function (roomname, username, reason) {
        if (reason === void 0) { reason = ''; }
        return __awaiter(this, void 0, void 0, function () {
            var url, body, resp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/invite/" + username;
                        body = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n        <mucInvitation>\n            <reason>" + reason + "</reason>\n        </mucInvitation>";
                        return [4 /*yield*/, this.rest.post(url, {
                                body: body,
                                headers: { 'Content-Type': 'application/xml' },
                            })];
                    case 1:
                        resp = _a.sent();
                        return [2 /*return*/, {
                                statusCode: resp.statusCode,
                                statusMessage: resp.statusMessage,
                            }];
                }
            });
        });
    };
    /**
     * Delete a user from a chat room
     * Endpoint to remove a room user role.
     */
    Chatroom.prototype.deleteUserFromChatroom = function (roomname, username, roles, servicename) {
        if (servicename === void 0) { servicename = 'conference'; }
        return __awaiter(this, void 0, void 0, function () {
            var url, status;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.endPoint + "/" + roomname + "/" + roles + "/" + username;
                        return [4 /*yield*/, this.rest.delete(url, { searchParams: { servicename: servicename } })];
                    case 1:
                        status = _a.sent();
                        return [2 /*return*/, status.statusCode];
                }
            });
        });
    };
    return Chatroom;
}());
exports.default = Chatroom;
//# sourceMappingURL=Chatroom.js.map